import os
import datetime

# Tipologie di thread: definisce una corrispondenza fra il nome nel package
# AADL e la tipologia di thread gestita dal code generator
class AADLThreadType():
    PUBLISHER   = 'publisher'   # Identifica i thread di tipo publisher

# In questa classe è presente il nome del modulo e della classe che gestisce la creazione di quel
# particolare tipo di thread. Un caso di esempio è il seguente.
# Thread di tipo publisher.
# Il nome del modulo che lo gestisce è threads.Publisher
# Il nome della classe all'interno del modulo è Publisher
class AADLThreadMapping():
    NAME_TO_CLASS = { AADLThreadType.PUBLISHER : "Publisher" }

# Classe da cui ereditano tutti i thread
class AADLThread():
    def __init__(self, process, thread, tags):
        dir = os.path.dirname(__file__)
        self.template_folder = os.path.join(dir, "..", "template", "threads")
        self.output_folder   = os.path.join(dir, "..", "src")

        try:
            os.mkdir( self.output_folder )
        except FileExistsError:
            pass

        self.process    = process
        self.thread     = thread
        self.tags       = tags

        self.name = process.find(self.tags['TAG_NAME']).text

        self.disclaimer = self.generate_disclaimer()

    def generate_code(self):
        raise NotImplementedError("generate_code deve essere implementata da ogni subclass di Thread")

    def generate_disclaimer(self):
        today = datetime.datetime.now()
        generated_on = today.strftime("%d/%m/%Y %H:%M:%S")

        disclaimer  = "/**\n"
        disclaimer += " * Node {}\n".format(self.name)
        disclaimer += " * File autogenerated on {}\n".format(generated_on)
        disclaimer += " */\n"

        return disclaimer

    def replace_placeholders(self, text, dict_replacements):
        text_output = text
        for key, value in dict_replacements.items():
            text_output = text_output.replace(key, value)
        return text_output